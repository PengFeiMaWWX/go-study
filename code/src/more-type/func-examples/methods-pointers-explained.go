package main

/**
使用的使函数
*/
import (
	"fmt"
	"math"
)

type Vertex struct {
	X, Y float64
}

func Abs(v Vertex) float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func Scale(v *Vertex, f float64) {
	v.X = v.X * f
	v.Y = v.Y * f
}
func main() {
	v := Vertex{3, 4}
	Scale(&v, 10)
	fmt.Println(Abs(v))
}

/**
1. 方法接收者与函数参数的区别
第一段代码将Abs和Scale定义为Vertex类型的方法。Abs方法使用值接收者(v Vertex)，而Scale方法使用指针接收者(v *Vertex)。方法调用通过点语法完成：v.Scale(10)和v.Abs()。
第二段代码将相同的操作定义为普通函数，需要显式传递参数。Abs函数接受一个Vertex值参数，而Scale函数需要一个Vertex指针参数。函数调用采用传统方式：Scale(&v, 10)和Abs(v)。
2. 指针语义与值语义的差异
两段代码都正确地处理了指针语义，确保Scale操作能修改原始对象。在第一段代码中，尽管v是值类型，但Go编译器会自动将v.Scale(10)解释为(&v).Scale(10)，这是Go为方法调用提供的语法糖。这种自动解引用机制简化了代码，但要求开发者明确理解接收者类型。
在第二段代码中，必须显式使用&v传递指针到Scale函数，没有自动转换机制。这种显式表达更清晰地表明了参数传递的语义，但代码稍显冗长。
3. 接口实现能力的不同
使用方法定义的一个重要优势是支持Go的接口机制。如果有一个接口需要Abs()方法，第一段代码中的Vertex类型可以实现该接口，而第二段代码中的函数定义无法直接与接口系统集成。Go的接口系统依赖于方法集而非函数集，这是面向接口编程的核心差异。
4. 设计哲学与代码组织
方法定义更适合面向对象的设计风格，将操作与数据类型紧密绑定，体现了封装的思想。函数定义则更符合过程式编程范式，将数据与操作分离。在大型项目中，方法定义通常能提供更好的封装性和可读性，特别是在需要实现多态行为时。
从输出结果来看，两段代码都会计算顶点(3,4)放大10倍后的模长，即点(30,40)的模长math.Sqrt(30 * 30 + 40 * 40) = 50，因此最终输出都是50。选择哪种方式取决于具体的设计需求和团队编码规范
*/
